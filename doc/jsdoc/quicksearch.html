<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes_Brush.js.html":{"id":"classes_Brush.js.html","title":"Source: classes/Brush.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: classes/Brush.js /** * @class Brush * instantinates a simple brush */ class Brush { /** * @constructor * @param {HTMLElement} pElement - html element acting as control to activate the tool */ constructor(pElement){ this.element = pElement; this.size = 3; } /** * method used to change the size of the brush * @param {event} event - wheel event that triggered method call */ changeBrushSize(event) { if(event.deltaY &lt; 0 &amp;&amp; this.size &lt; 200){ this.size++; } if(event.deltaY &gt; 0 &amp;&amp; this.size &gt; 1){ this.size--; } } } export { Brush }; × Search results Close "},"util_calculateDistance.js.html":{"id":"util_calculateDistance.js.html","title":"Source: util/calculateDistance.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: util/calculateDistance.js /** * calculates the distance between 2 positions * @param p1 {Object} - x and y coordinate of point 1 * @param p2 {Object} - x and y coordinate of point 2 * @returns {number} */ const calculateDistance = function (p1 = {x: 0, y: 0}, p2 = {x: 0, y: 0}) { let xLen = Math.pow((p2.x - p1.x), 2), yLen = Math.pow((p2.y - p1.y), 2); return Math.sqrt(xLen + yLen); }; export { calculateDistance }; × Search results Close "},"util_randomInt.js.html":{"id":"util_randomInt.js.html","title":"Source: util/randomInt.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: util/randomInt.js /** * function to generate a random integer value * @param min {number} - minimum value * @param max {number} - maximum value * @returns {number} */ const getRandomInt = (min, max) =&gt; { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min +1)) + min; }; export {getRandomInt}; × Search results Close "},"classes_LayerStack.js.html":{"id":"classes_LayerStack.js.html","title":"Source: classes/LayerStack.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: classes/LayerStack.js /** * @class LayerStack * instantinates a layer stack for layered images * handles controls and operations to work with layers */ class LayerStack { /** * @constructor * @param pStage {HTMLElement} - html element that contains generated canvas layers * @param pControlWrapper {HTMLElement} - html element that displays layer controls * @param fPropagateActive {function} - function used to set the actual canvas context */ constructor(pStage, pControlWrapper, fPropagateActive) { this.stage = pStage; this.layers = []; this.layerControls = []; this.controlWrapper = pControlWrapper; this.propagateActive = fPropagateActive; this.layerIdCount = 0; // initialize first layer this.createCanvas(this.layers.length); // populate first layer as active layer this.propagateActive(this.layers[0]); } /** * creates a canvas element to the dom and the layer stack * and adds a control element for the generated canvas element * @returns {HTMLElement} - generated canvas element */ createCanvas (){ const stage = this.stage; const controlWrapper = this.controlWrapper; const id = `layer${this.layerIdCount}`; // create canvas element let elem = document.createElement('canvas'); elem.setAttribute('class', 'layer'); elem.setAttribute('id', id); elem.setAttribute('width', stage.clientWidth ); elem.setAttribute('height', stage.clientHeight ); // create layer control element // add childrend and add eventListeners let layerElem = document.createElement('div'); layerElem.setAttribute('class', 'layer-control active'); layerElem.setAttribute('id', `layerControl${this.layerIdCount}`); let layerTitle = document.createElement('div'); layerTitle.setAttribute('class', 'layer-title'); layerTitle.innerText = `Layer ${this.layerIdCount + 1}`; let layerActions = document.createElement('div'); layerActions.setAttribute('class', 'layer-actions'); let layerSelectAction = document.createElement('span'); layerSelectAction.addEventListener('click', () =&gt; { this.selectLayer(id);}); let layerSelectIcon = document.createElement('i'); layerSelectIcon.setAttribute('class', 'fas fa-pencil-alt fa-1x layer-action'); let layerHideAction = document.createElement('span'); layerHideAction.setAttribute('id', `layerControlHide${this.layerIdCount}`); layerHideAction.addEventListener('click', () =&gt; { this.hideLayer(id);}); let layerHideIcon = document.createElement('i'); layerHideIcon.setAttribute('class', 'fas fa-eye fa-1x layer-action'); let layerDeleteAction = document.createElement('span'); layerDeleteAction.addEventListener('click', () =&gt; { this.deleteLayer(id); }); let layerDeleteIcon = document.createElement('i'); layerDeleteIcon.setAttribute('class', 'fas fa-trash fa-1x layer-action'); // append stage.append(elem); this.layers.push(elem); // create nested layer Element layerSelectAction.append(layerSelectIcon); layerHideAction.append(layerHideIcon); layerDeleteAction.append(layerDeleteIcon); layerActions.append(layerSelectAction); layerActions.append(layerHideAction); layerActions.append(layerDeleteAction); layerElem.append(layerTitle); layerElem.append(layerActions); // prepend layer control above other layers controlWrapper.prepend(layerElem); this.layerControls.push(layerElem); this.selectLayer(id); this.layerIdCount++; return elem; } /** * toggles layer visibility within the stage * @param pId {String} - id of the html element (canvas) to be hidden */ hideLayer(pId) { let layer = this.getLayer(pId); let layerControl = document.getElementById('layerControlHide'+ pId.substr(5)); layerControl.classList.toggle('layer-invisible'); layer.classList.toggle('hidden'); } /** * deletes a layer based on its id * deletes the layer control and removes it from the layerstack * @param pId {String} - id of the html element (canvas) to be hidden */ deleteLayer(pId) { let numericId = pId.substr(5); let layer = this.getLayer(pId); let layerControl = document.getElementById(`layerControl${numericId}`); // get the index of the layer in layers stack let index = this.layers.findIndex(layer =&gt; layer.id === pId); // remove layer from layers stack this.layers.splice(index, 1); // remove layer from dom layer.remove(); // remove layer control from dom layerControl.remove(); // set first layer as active layer this.selectLayer(this.layers[this.layers.length-1].id); } /** * returns a layer based on its id * @param pId {String} - id of the html element (canvas) to be returned * @returns {HTMLElement} - returns found html element or undefined */ getLayer(pId){ return this.layers.find((elem) =&gt; { if(elem.id === pId) { return elem; } }); } /** * propagates a layer to activate its context, * marks layer control as active layer by adding a simple css class * @param pId {String} - id of the html element (canvas) to be selected */ selectLayer(pId){ const layer = this.getLayer(pId); this.propagateActive(layer); const numId = pId.substr(5); this.layerControls.forEach((lc) =&gt; { lc.classList.remove('active'); }); document.getElementById('layerControl' + numId).classList.add('active'); } /** * resets the current project layerstack, controls to defaults */ reset(){ this.layers = []; this.layerControls = []; this.layerIdCount = 0; this.controlWrapper.innerHTML = ''; let layers = document.querySelectorAll('.layer'); layers.forEach( el =&gt; el.remove()); } /** * restores a project from local storage * @param pProject {Array} - array of layer image data uris for the content of each layer */ restore(pProject){ this.reset(); const images = []; const canvases = []; Object.keys(pProject).forEach(key =&gt; { let img = new Image; let canvas = this.createCanvas(); img.src = pProject[key]; images.push(img); canvases.push(canvas); }); setTimeout(() =&gt; { for(let i = 0; i &lt; images.length; i++){ let ctx = canvases[i].getContext('2d'); ctx.drawImage(images[i],0,0); } }, 500); } } export { LayerStack }; × Search results Close "},"util_fakeServer.js.html":{"id":"util_fakeServer.js.html","title":"Source: util/fakeServer.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: util/fakeServer.js /** * function to save data to the localStorage * @param data {Object} - data to be stringified and stored * @param callback */ const save = function (data, callback) { setTimeout(() =&gt; { let err = null; try { localStorage.setItem('paintifyImg', JSON.stringify(data)); } catch (e) { err = e; } callback(err); }, 1000); // fake a response delay with 1000ms }; /** * function to load data from the localStorage * @param callback */ const load = function (callback) { setTimeout(() =&gt; { let err = null; let data; try { data = JSON.parse(localStorage.getItem('paintifyImg')); } catch (e) { err = e; } callback(err, data); }, 1000); // fake a response delay with 1000ms }; export{save, load}; × Search results Close "},"classes_Paintify.js.html":{"id":"classes_Paintify.js.html","title":"Source: classes/Paintify.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: classes/Paintify.js import { Brush } from './Brush'; import { LayerStack } from './LayerStack'; import { save, load } from '../util/fakeServer'; import { calculateDistance } from '../util/calculateDistance'; import { getRandomInt } from '../util/randomInt'; /** * @class Paintify * instantinates a paintify object that handles simple canvas painting */ class Paintify { /** * @constructor * @param {{colorSet: Object, * dom: Object}} pConfig * * @param pConfig.colorSet {Array} - array of colors &lt;code&gt;{ \"name\": \"yellow\", \"hexValue\": \"FFD747\"}&lt;/code&gt; * @param pConfig.dom {Object} - HTML Element Ids to mount paintify functionality to * @param pConfig.dom.brush {String} - element to trigger brush tool activation * @param pConfig.dom.eraser {String} - element to trigger eraser tool activation * @param pConfig.dom.circle {String} - element to trigger circle tool activation * @param pConfig.dom.rectangle {String} - element to trigger rectangle tool activation * @param pConfig.dom.colorBomb {String} - element to trigger color bomb tool activation * @param pConfig.dom.reset {String} - element to reset to defaults * @param pConfig.dom.addLayer {String} - element to add a new layer * @param pConfig.dom.stage {String} - element that contains created layers * @param pConfig.dom.layerControl {String} - element that contains layer controls * @param pConfig.dom.colorPalette {String} - element to mount colors based on colorSet config * @param pConfig.dom.menuToggle {String} - element that toggles main menu * @param pConfig.dom.menuClose {String} - element that closes main menu * @param pConfig.dom.saveProject {String} - button to save project to local storage * @param pConfig.dom.loadProject {String} - button to load recent project from local storage * @param pConfig.dom.downloadImage {String} - button to download artwork as png * @param pConfig.dom.downloadActiveLayer {String} - button to download recently activated layer */ constructor({ config: pConfig }){ this.config = pConfig; this.drawPosition = {x: 0, y: 0}; this.distanceFrom = {x: 0, y: 0}; this.activeTool = ''; this.activeColor = ''; this.activeLayer = ''; this.actionsModal = false; this.domElements = {}; this.domControls = {}; this.activateLayer = this.activateLayer.bind(this); this.initApp(); } /** * initializes the paintify instance based on paintify.config.json */ initApp(){ const config = this.config; const domElements = this.domElements; // set configured dom elements Object.keys(config.dom).forEach((key) =&gt; { domElements[key] = document.getElementById(config.dom[key]); }); // initialize brush this.initBrush(domElements); // initialize eraser this.initEraser(domElements); // initialize circle tool this.initCircleTool(domElements); // initialize rectangle tool this.initRectTool(domElements); // initialize color bomb this.initColorBomb(domElements); // initialize color palette this.initColorPalette(config.colorSet, domElements); // initialize layerstack this.layerStack = new LayerStack( domElements.stage, domElements.layerControl, this.activateLayer ); // init windowListeners this.initWindowListeners(); // initialize further buttons domElements.reset.addEventListener('click', () =&gt; { this.layerStack.reset(); this.layerStack.createCanvas(); }); domElements.addLayer.addEventListener('click', () =&gt; { this.layerStack.createCanvas(); }); domElements.menuToggle.addEventListener('click', () =&gt; { this.toggleMenu(); }); domElements.menuClose.addEventListener('click', () =&gt; { this.toggleMenu(); }); domElements.saveProject.addEventListener('click', () =&gt; { this.saveProject(); }); domElements.loadProject.addEventListener('click', () =&gt; { this.loadProject(); }); domElements.downloadImage.addEventListener('click', () =&gt; { this.downloadMergedImage();}); domElements.downloadActiveLayer.addEventListener('click', () =&gt; {this.downloadLayerImage();}); } /** * initializes the brush tool based on Brush class * adds a eventlistener to html element and adds tools to instance domControls * @param dom {HTMLElement} - HTML Element matched to id from pConfig.dom.brush */ initBrush(dom){ // initialize paintify brush instance this.brush = new Brush(dom.brush); this.brush.element.addEventListener('click', () =&gt; { this.activeTool = 'brush'; this.setActiveToolClass('brush'); }); this.domControls['brush'] = this.brush.element; this.activeTool = 'brush'; } /** * initializes the eraser tool based on Brush class * adds a eventlistener to html element and adds tools to instance domControls * @param dom {HTMLElement} - HTML Element matched to id from pConfig.dom.eraser */ initEraser(dom){ // initialize paintify eraser instance this.eraser = new Brush(dom.eraser); this.domControls['eraser'] = this.eraser.element; this.eraser.element.addEventListener('click', () =&gt; { this.activeTool = 'eraser'; this.setActiveToolClass('eraser'); }); } /** * initializes the circle tool * adds a eventlistener to html element and adds tools to instance domControls * @param dom {HTMLElement} - HTML Element matched to id from pConfig.dom.circle */ initCircleTool(dom){ dom.circle.addEventListener('click', () =&gt; { this.activeTool = 'circle'; this.setActiveToolClass('circle'); }); this.domControls['circle'] = dom.circle; } /** * initializes the rectangle tool, * adds a eventlistener to html element and adds tools to instance domControls * @param dom {HTMLElement} - HTML Element matched to id from pConfig.dom.rectangle */ initRectTool(dom){ dom.rectangle.addEventListener('click', () =&gt; { this.activeTool = 'rectangle'; this.setActiveToolClass('rectangle'); }); this.domControls['rectangle'] = dom.rectangle; } /** * initializes the color bomb tool, * adds a eventlistener to html element and adds tools to instance domControls * @param dom {HTMLElement} - HTML Element matched to id from pConfig.dom.colorBomb */ initColorBomb(dom){ dom.colorBomb.addEventListener('click', () =&gt; { this.activeTool = 'bomb'; this.setActiveToolClass('bomb'); }); this.domControls['bomb'] = dom.colorBomb; } /** * generates color controls and mounts controls to the dom * @param pColorSet {Array} - array of colors set in config.colorSet * @param pControls {Object} - HTML Elements created from init method */ initColorPalette(pColorSet, pControls){ let i = 0; pColorSet.forEach((color) =&gt; { let elem = document.createElement('div'); elem.setAttribute('class', 'colorElement'); elem.setAttribute('data-value', color.hexValue); elem.setAttribute('id', color.name); elem.setAttribute('data-key', i); elem.setAttribute('style', `background-color: #${color.hexValue}`); elem.addEventListener('click', (event) =&gt; { this.activeColor = document.getElementById(event.target.id).getAttribute('data-value'); }); pControls.colorPalette.appendChild(elem); i++; }); this.activeColor = pColorSet[0].hexValue; } /** * initializes window listeners for mouse events */ initWindowListeners(){ this.domElements.stage.addEventListener('mousemove', (e) =&gt; { this.draw(e); this.drawStrokeThickness(e); }); this.domElements.stage.addEventListener('mousedown', (e) =&gt; { this.setDrawPosition(e); this.setMeasurePosition(e); }); this.domElements.stage.addEventListener('mouseenter', (e) =&gt; { this.setDrawPosition(e); }); this.domElements.stage.addEventListener('wheel', (e) =&gt; { this.setBrushSize(e); this.drawStrokeThickness(e); }); } /** * activates a specific layer to draw on * @param pLayer {HTMLCanvasElement} */ activateLayer(pLayer){ this.activeLayer = pLayer; } /** * adds css class to active tool control * @param pTool {String} - tool string name */ setActiveToolClass(pTool){ const tools = this.domControls; Object.keys(tools).forEach((key) =&gt; { if(pTool === key){ tools[key].classList.add('active'); } else { tools[key].classList.remove('active'); } }); } /** * sets current mouse position * @param event {MouseEvent} - event delivers positional data */ setDrawPosition(event){ this.drawPosition.x = event.clientX - 70; this.drawPosition.y = event.clientY; } /** * sets current mouse position for distance measuring (circle, rectangle) * @param event {MouseEvent} - event delivers positional data */ setMeasurePosition(event){ this.distanceFrom.x = event.clientX - 70; this.distanceFrom.y = event.clientY; } /** * checks activated tool and recieves context from activated layer * @param event {MouseEvent} - mousemove */ draw(event){ if(!this.actionsModal){ // get active layer context const ctx = this.activeLayer.getContext('2d'); // set active color as css hex value let color = `#${this.activeColor}`; if(event.buttons === 1){ switch(this.activeTool){ case 'eraser': this.erase( event, ctx); break; case 'brush': this.drawBrushStroke( event, ctx, color); break; case 'circle': this.setDrawPosition(event); this.drawCircle(ctx, color); break; case 'rectangle': this.setDrawPosition(event); this.drawRectangle(ctx, color); break; case 'bomb': this.setDrawPosition(event); this.drawBomb(ctx); break; } } } } /** * draws a brush stroke to the active layer / canvas * @param event {MouseEvent} - event used for positioning * @param ctx {CanvasRenderingContext2D} - context of active layer (canvas element) * @param color {String} - HEX value of color to draw with */ drawBrushStroke(event, ctx, color){ ctx.beginPath(); ctx.lineWidth = this.brush.size; ctx.globalCompositeOperation = 'source-over'; ctx.lineCap = 'round'; ctx.strokeStyle = color; ctx.moveTo(this.drawPosition.x, this.drawPosition.y); this.setDrawPosition(event); ctx.lineTo(this.drawPosition.x, this.drawPosition.y); ctx.stroke(); ctx.closePath(); } /** * erases parts of the active layer / canvas element * @param event {MouseEvent} - event used for positioning * @param ctx {CanvasRenderingContext2D} - context of active layer (canvas element) */ erase(event, ctx){ ctx.beginPath(); ctx.lineWidth = this.eraser.size; ctx.globalCompositeOperation = 'destination-out'; ctx.lineCap = 'round'; ctx.moveTo(this.drawPosition.x, this.drawPosition.y); this.setDrawPosition(event); ctx.lineTo(this.drawPosition.x, this.drawPosition.y); ctx.stroke(); ctx.closePath(); } /** * draws a circle on the active layer / canvas element * @param ctx {CanvasRenderingContext2D} - context of active layer (canvas element) * @param color {String} - HEX value of color to draw with */ drawCircle(ctx, color) { let dist = calculateDistance(this.drawPosition, this.distanceFrom); ctx.beginPath(); ctx.globalCompositeOperation = 'source-over'; ctx.arc(this.distanceFrom.x , this.distanceFrom.y , dist ,0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); ctx.closePath(); } /** * draws a rectangle on the active layer / canvas element * @param ctx {CanvasRenderingContext2D} - context of active layer (canvas element) * @param color {String} - HEX value of color to draw with */ drawRectangle(ctx, color) { let xLen = Math.abs(this.distanceFrom.x - this.drawPosition.x); let yLen = Math.abs(this.distanceFrom.y - this.drawPosition.y); ctx.beginPath(); ctx.fillRect(this.distanceFrom.x , this.distanceFrom.y, xLen, yLen); ctx.fillStyle = color; ctx.fill(); ctx.closePath(); } /** * draws multiple circles with various diameters and colors around mouse position * @param ctx {CanvasRenderingContext2D} - context of active layer (canvas element) */ drawBomb(ctx){ let colorSet = this.config.colorSet; let color = 0; let rad = 0; let distX = 0; let distY = 0; for(let i = 0; i &lt; 50; i++){ color = colorSet[getRandomInt(0, colorSet.length)].hexValue; rad = getRandomInt(5, 25); distX = getRandomInt(-250, 250); distY = getRandomInt(-250,250); ctx.beginPath(); ctx.globalCompositeOperation = 'source-over'; ctx.arc(this.drawPosition.x + distX, this.drawPosition.y + distY, rad ,0, Math.PI * 2); ctx.fillStyle = `#${color}`; ctx.fill(); ctx.closePath(); } } /** * sets the brush size of either brush or eraser if activated * @param event {MouseEvent} - wheel */ setBrushSize(event){ const activeTool = this.activeTool; let tool = this.brush; if(activeTool === 'eraser'){ tool = this.eraser; } tool.changeBrushSize(event); } /** * Method to assist user while painting, displays brush or eraser dimensions * @param event {MouseEvent} - used to obtain mouse position */ drawStrokeThickness(event){ const thicknessElem = document.getElementById('strokeHelper'); if(!this.actionsModal &amp;&amp; (this.activeTool === 'brush' || this.activeTool === 'eraser')){ const activeTool = this.activeTool; let tool = this.brush; if(activeTool === 'eraser'){ tool = this.eraser; } let width = tool.size; let height = tool.size; let top = event.clientY - tool.size / 2; let left = event.clientX - 70 - tool.size / 2; thicknessElem.setAttribute('style', `width: ${width}px; height: ${height}px; top: ${top}px; left: ${left}px`); } else { thicknessElem.setAttribute('style', 'width: 0px; height: 0px; top: -100px; left: -100px'); } } /** * saves a project to the localStorage */ saveProject(){ const layers = this.layerStack.layers; const project = {}; layers.forEach( layer =&gt; { project[layer.id] = layer.toDataURL('image/png'); }); save(project, () =&gt; { alert('Project Saved');}); } /** * loads a project from the localStorage */ loadProject(){ const project = (err, data) =&gt; { if(data !== undefined &amp;&amp; data !== null){ this.layerStack.restore(data); } else { alert('No previous saved project available.');} }; load(project); } /** * downloads the artwork / project by merging layers to a single image png file */ downloadMergedImage(){ // create new canvas element to merge all layers const merged = this.layerStack.createCanvas(); const layers = this.layerStack.layers; const ctx = merged.getContext('2d'); layers.forEach((layer) =&gt; { ctx.drawImage(layer, 0,0); }); this.downloadLayerImage(); this.layerStack.deleteLayer(merged.id); } /** * downloads the active layer as png file */ downloadLayerImage(){ const image = this.activeLayer.toDataURL('image/png'); const tmpLink = document.createElement('a'); tmpLink.download = 'paintify.png'; tmpLink.href = image; document.body.appendChild(tmpLink); tmpLink.click(); document.body.removeChild(tmpLink); } /** * toggles the menu */ toggleMenu() { if(this.actionsModal){ this.actionsModal = false; document.getElementById('actionsModal').classList.add('closed'); } else { this.actionsModal = true; document.getElementById('actionsModal').classList.remove('closed'); } } } export { Paintify }; × Search results Close "},"util_wait.js.html":{"id":"util_wait.js.html","title":"Source: util/wait.js","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Source: util/wait.js /** * function to be able to simply wait for some time * @param pTime {number} - time in ms * @returns {Promise&lt;any&gt;} */ const wait = pTime =&gt; new Promise(pResolve =&gt; setTimeout(pResolve, pTime)); export {wait}; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Global Methods calculateDistance(p1, p2) calculates the distance between 2 positions Parameters: Name Type Description p1 Object x and y coordinate of point 1 p2 Object x and y coordinate of point 2 Source: util/calculateDistance.js, line 8 Returns: Type number getRandomInt(min, max) function to generate a random integer value Parameters: Name Type Description min number minimum value max number maximum value Source: util/randomInt.js, line 8 Returns: Type number load(callback) function to load data from the localStorage Parameters: Name Type Description callback Source: util/fakeServer.js, line 25 save(data, callback) function to save data to the localStorage Parameters: Name Type Description data Object data to be stringified and stored callback Source: util/fakeServer.js, line 7 wait(pTime) function to be able to simply wait for some time Parameters: Name Type Description pTime number time in ms Source: util/wait.js, line 7 Returns: Type Promise.&lt;any&gt; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Classes Classes Brush LayerStack Paintify × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait × Search results Close "},"Brush.html":{"id":"Brush.html","title":"Class: Brush","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Class: Brush Brush Brush instantinates a simple brush new Brush(pElement) Parameters: Name Type Description pElement HTMLElement html element acting as control to activate the tool Source: classes/Brush.js, line 11 Methods changeBrushSize(event) method used to change the size of the brush Parameters: Name Type Description event event wheel event that triggered method call Source: classes/Brush.js, line 20 × Search results Close "},"LayerStack.html":{"id":"LayerStack.html","title":"Class: LayerStack","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Class: LayerStack LayerStack LayerStack instantinates a layer stack for layered images handles controls and operations to work with layers new LayerStack(pStage, pControlWrapper, fPropagateActive) Parameters: Name Type Description pStage HTMLElement html element that contains generated canvas layers pControlWrapper HTMLElement html element that displays layer controls fPropagateActive function function used to set the actual canvas context Source: classes/LayerStack.js, line 14 Methods createCanvas() creates a canvas element to the dom and the layer stack and adds a control element for the generated canvas element Source: classes/LayerStack.js, line 33 Returns: - generated canvas element Type HTMLElement deleteLayer(pId) deletes a layer based on its id deletes the layer control and removes it from the layerstack Parameters: Name Type Description pId String id of the html element (canvas) to be hidden Source: classes/LayerStack.js, line 132 getLayer(pId) returns a layer based on its id Parameters: Name Type Description pId String id of the html element (canvas) to be returned Source: classes/LayerStack.js, line 156 Returns: - returns found html element or undefined Type HTMLElement hideLayer(pId) toggles layer visibility within the stage Parameters: Name Type Description pId String id of the html element (canvas) to be hidden Source: classes/LayerStack.js, line 118 reset() resets the current project layerstack, controls to defaults Source: classes/LayerStack.js, line 186 restore(pProject) restores a project from local storage Parameters: Name Type Description pProject Array array of layer image data uris for the content of each layer Source: classes/LayerStack.js, line 200 selectLayer(pId) propagates a layer to activate its context, marks layer control as active layer by adding a simple css class Parameters: Name Type Description pId String id of the html element (canvas) to be selected Source: classes/LayerStack.js, line 169 × Search results Close "},"Paintify.html":{"id":"Paintify.html","title":"Class: Paintify","body":" Paintify Classes BrushLayerStackPaintify Global calculateDistancegetRandomIntloadsavewait Class: Paintify Paintify Paintify instantinates a paintify object that handles simple canvas painting new Paintify(pConfig) Parameters: Name Type Description pConfig Object Properties Name Type Description colorSet Array array of colors { \"name\": \"yellow\", \"hexValue\": \"FFD747\"} dom Object HTML Element Ids to mount paintify functionality to Properties Name Type Description brush String element to trigger brush tool activation eraser String element to trigger eraser tool activation circle String element to trigger circle tool activation rectangle String element to trigger rectangle tool activation colorBomb String element to trigger color bomb tool activation reset String element to reset to defaults addLayer String element to add a new layer stage String element that contains created layers layerControl String element that contains layer controls colorPalette String element to mount colors based on colorSet config menuToggle String element that toggles main menu menuClose String element that closes main menu saveProject String button to save project to local storage loadProject String button to load recent project from local storage downloadImage String button to download artwork as png downloadActiveLayer String button to download recently activated layer Source: classes/Paintify.js, line 37 Methods activateLayer(pLayer) activates a specific layer to draw on Parameters: Name Type Description pLayer HTMLCanvasElement Source: classes/Paintify.js, line 232 downloadLayerImage() downloads the active layer as png file Source: classes/Paintify.js, line 493 downloadMergedImage() downloads the artwork / project by merging layers to a single image png file Source: classes/Paintify.js, line 474 draw(event) checks activated tool and recieves context from activated layer Parameters: Name Type Description event MouseEvent mousemove Source: classes/Paintify.js, line 274 drawBomb(ctx) draws multiple circles with various diameters and colors around mouse position Parameters: Name Type Description ctx CanvasRenderingContext2D context of active layer (canvas element) Source: classes/Paintify.js, line 380 drawBrushStroke(event, ctx, color) draws a brush stroke to the active layer / canvas Parameters: Name Type Description event MouseEvent event used for positioning ctx CanvasRenderingContext2D context of active layer (canvas element) color String HEX value of color to draw with Source: classes/Paintify.js, line 314 drawCircle(ctx, color) draws a circle on the active layer / canvas element Parameters: Name Type Description ctx CanvasRenderingContext2D context of active layer (canvas element) color String HEX value of color to draw with Source: classes/Paintify.js, line 349 drawRectangle(ctx, color) draws a rectangle on the active layer / canvas element Parameters: Name Type Description ctx CanvasRenderingContext2D context of active layer (canvas element) color String HEX value of color to draw with Source: classes/Paintify.js, line 365 drawStrokeThickness(event) Method to assist user while painting, displays brush or eraser dimensions Parameters: Name Type Description event MouseEvent used to obtain mouse position Source: classes/Paintify.js, line 421 erase(event, ctx) erases parts of the active layer / canvas element Parameters: Name Type Description event MouseEvent event used for positioning ctx CanvasRenderingContext2D context of active layer (canvas element) Source: classes/Paintify.js, line 332 initApp() initializes the paintify instance based on paintify.config.json Source: classes/Paintify.js, line 55 initBrush(dom) initializes the brush tool based on Brush class adds a eventlistener to html element and adds tools to instance domControls Parameters: Name Type Description dom HTMLElement HTML Element matched to id from pConfig.dom.brush Source: classes/Paintify.js, line 110 initCircleTool(dom) initializes the circle tool adds a eventlistener to html element and adds tools to instance domControls Parameters: Name Type Description dom HTMLElement HTML Element matched to id from pConfig.dom.circle Source: classes/Paintify.js, line 142 initColorBomb(dom) initializes the color bomb tool, adds a eventlistener to html element and adds tools to instance domControls Parameters: Name Type Description dom HTMLElement HTML Element matched to id from pConfig.dom.colorBomb Source: classes/Paintify.js, line 170 initColorPalette(pColorSet, pControls) generates color controls and mounts controls to the dom Parameters: Name Type Description pColorSet Array array of colors set in config.colorSet pControls Object HTML Elements created from init method Source: classes/Paintify.js, line 184 initEraser(dom) initializes the eraser tool based on Brush class adds a eventlistener to html element and adds tools to instance domControls Parameters: Name Type Description dom HTMLElement HTML Element matched to id from pConfig.dom.eraser Source: classes/Paintify.js, line 127 initRectTool(dom) initializes the rectangle tool, adds a eventlistener to html element and adds tools to instance domControls Parameters: Name Type Description dom HTMLElement HTML Element matched to id from pConfig.dom.rectangle Source: classes/Paintify.js, line 156 initWindowListeners() initializes window listeners for mouse events Source: classes/Paintify.js, line 210 loadProject() loads a project from the localStorage Source: classes/Paintify.js, line 460 saveProject() saves a project to the localStorage Source: classes/Paintify.js, line 446 setActiveToolClass(pTool) adds css class to active tool control Parameters: Name Type Description pTool String tool string name Source: classes/Paintify.js, line 240 setBrushSize(event) sets the brush size of either brush or eraser if activated Parameters: Name Type Description event MouseEvent wheel Source: classes/Paintify.js, line 406 setDrawPosition(event) sets current mouse position Parameters: Name Type Description event MouseEvent event delivers positional data Source: classes/Paintify.js, line 256 setMeasurePosition(event) sets current mouse position for distance measuring (circle, rectangle) Parameters: Name Type Description event MouseEvent event delivers positional data Source: classes/Paintify.js, line 265 toggleMenu() toggles the menu Source: classes/Paintify.js, line 508 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
